/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "app_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Server {


Suggestion::~Suggestion() throw() {
}


void Suggestion::__set_measure(const std::string& val) {
  this->measure = val;
}

void Suggestion::__set_dimension(const std::string& val) {
  this->dimension = val;
}

void Suggestion::__set_chart_type(const std::string& val) {
  this->chart_type = val;
}

void Suggestion::__set_aggregate_type(const std::string& val) {
  this->aggregate_type = val;
}

void Suggestion::__set_statistical_method(const std::string& val) {
  this->statistical_method = val;
}

void Suggestion::__set_group_by_raw_data(const std::map<std::string, std::vector<std::string> > & val) {
  this->group_by_raw_data = val;
}

void Suggestion::__set_aggregate_data(const std::map<std::string, double> & val) {
  this->aggregate_data = val;
}

void Suggestion::__set_score(const double val) {
  this->score = val;
}

uint32_t Suggestion::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_measure = false;
  bool isset_dimension = false;
  bool isset_chart_type = false;
  bool isset_aggregate_type = false;
  bool isset_statistical_method = false;
  bool isset_group_by_raw_data = false;
  bool isset_aggregate_data = false;
  bool isset_score = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->measure);
          isset_measure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dimension);
          isset_dimension = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->chart_type);
          isset_chart_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->aggregate_type);
          isset_aggregate_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statistical_method);
          isset_statistical_method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->group_by_raw_data.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              std::vector<std::string> & _val6 = this->group_by_raw_data[_key5];
              {
                _val6.clear();
                uint32_t _size7;
                ::apache::thrift::protocol::TType _etype10;
                xfer += iprot->readListBegin(_etype10, _size7);
                _val6.resize(_size7);
                uint32_t _i11;
                for (_i11 = 0; _i11 < _size7; ++_i11)
                {
                  xfer += iprot->readString(_val6[_i11]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          isset_group_by_raw_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->aggregate_data.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _ktype13;
            ::apache::thrift::protocol::TType _vtype14;
            xfer += iprot->readMapBegin(_ktype13, _vtype14, _size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              std::string _key17;
              xfer += iprot->readString(_key17);
              double& _val18 = this->aggregate_data[_key17];
              xfer += iprot->readDouble(_val18);
            }
            xfer += iprot->readMapEnd();
          }
          isset_aggregate_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->score);
          isset_score = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_measure)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dimension)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_chart_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_aggregate_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statistical_method)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_group_by_raw_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_aggregate_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_score)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Suggestion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Suggestion");

  xfer += oprot->writeFieldBegin("measure", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->measure);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dimension", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dimension);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chart_type", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->chart_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aggregate_type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->aggregate_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statistical_method", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->statistical_method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("group_by_raw_data", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->group_by_raw_data.size()));
    std::map<std::string, std::vector<std::string> > ::const_iterator _iter19;
    for (_iter19 = this->group_by_raw_data.begin(); _iter19 != this->group_by_raw_data.end(); ++_iter19)
    {
      xfer += oprot->writeString(_iter19->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter19->second.size()));
        std::vector<std::string> ::const_iterator _iter20;
        for (_iter20 = _iter19->second.begin(); _iter20 != _iter19->second.end(); ++_iter20)
        {
          xfer += oprot->writeString((*_iter20));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aggregate_data", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->aggregate_data.size()));
    std::map<std::string, double> ::const_iterator _iter21;
    for (_iter21 = this->aggregate_data.begin(); _iter21 != this->aggregate_data.end(); ++_iter21)
    {
      xfer += oprot->writeString(_iter21->first);
      xfer += oprot->writeDouble(_iter21->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("score", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->score);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Suggestion &a, Suggestion &b) {
  using ::std::swap;
  swap(a.measure, b.measure);
  swap(a.dimension, b.dimension);
  swap(a.chart_type, b.chart_type);
  swap(a.aggregate_type, b.aggregate_type);
  swap(a.statistical_method, b.statistical_method);
  swap(a.group_by_raw_data, b.group_by_raw_data);
  swap(a.aggregate_data, b.aggregate_data);
  swap(a.score, b.score);
}

Suggestion::Suggestion(const Suggestion& other22) {
  measure = other22.measure;
  dimension = other22.dimension;
  chart_type = other22.chart_type;
  aggregate_type = other22.aggregate_type;
  statistical_method = other22.statistical_method;
  group_by_raw_data = other22.group_by_raw_data;
  aggregate_data = other22.aggregate_data;
  score = other22.score;
}
Suggestion& Suggestion::operator=(const Suggestion& other23) {
  measure = other23.measure;
  dimension = other23.dimension;
  chart_type = other23.chart_type;
  aggregate_type = other23.aggregate_type;
  statistical_method = other23.statistical_method;
  group_by_raw_data = other23.group_by_raw_data;
  aggregate_data = other23.aggregate_data;
  score = other23.score;
  return *this;
}
void Suggestion::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Suggestion(";
  out << "measure=" << to_string(measure);
  out << ", " << "dimension=" << to_string(dimension);
  out << ", " << "chart_type=" << to_string(chart_type);
  out << ", " << "aggregate_type=" << to_string(aggregate_type);
  out << ", " << "statistical_method=" << to_string(statistical_method);
  out << ", " << "group_by_raw_data=" << to_string(group_by_raw_data);
  out << ", " << "aggregate_data=" << to_string(aggregate_data);
  out << ", " << "score=" << to_string(score);
  out << ")";
}


Attribute::~Attribute() throw() {
}


void Attribute::__set_attribute(const std::string& val) {
  this->attribute = val;
}

uint32_t Attribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_attribute = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->attribute);
          isset_attribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_attribute)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Attribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Attribute");

  xfer += oprot->writeFieldBegin("attribute", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->attribute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Attribute &a, Attribute &b) {
  using ::std::swap;
  swap(a.attribute, b.attribute);
}

Attribute::Attribute(const Attribute& other24) {
  attribute = other24.attribute;
}
Attribute& Attribute::operator=(const Attribute& other25) {
  attribute = other25.attribute;
  return *this;
}
void Attribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Attribute(";
  out << "attribute=" << to_string(attribute);
  out << ")";
}

} // namespace
