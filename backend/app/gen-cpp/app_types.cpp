/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "app_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Server {


Suggestion::~Suggestion() throw() {
}


void Suggestion::__set_measure(const std::string& val) {
  this->measure = val;
}

void Suggestion::__set_dimension(const std::string& val) {
  this->dimension = val;
}

void Suggestion::__set_chart_type(const std::string& val) {
  this->chart_type = val;
}

void Suggestion::__set_aggregate_type(const std::string& val) {
  this->aggregate_type = val;
}

void Suggestion::__set_statistical_method(const std::string& val) {
  this->statistical_method = val;
}

void Suggestion::__set_aggregate_data(const std::map<std::string, double> & val) {
  this->aggregate_data = val;
}

void Suggestion::__set_score(const double val) {
  this->score = val;
}

uint32_t Suggestion::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_measure = false;
  bool isset_dimension = false;
  bool isset_chart_type = false;
  bool isset_aggregate_type = false;
  bool isset_statistical_method = false;
  bool isset_aggregate_data = false;
  bool isset_score = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->measure);
          isset_measure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dimension);
          isset_dimension = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->chart_type);
          isset_chart_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->aggregate_type);
          isset_aggregate_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statistical_method);
          isset_statistical_method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->aggregate_data.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              double& _val6 = this->aggregate_data[_key5];
              xfer += iprot->readDouble(_val6);
            }
            xfer += iprot->readMapEnd();
          }
          isset_aggregate_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->score);
          isset_score = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_measure)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dimension)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_chart_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_aggregate_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statistical_method)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_aggregate_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_score)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Suggestion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Suggestion");

  xfer += oprot->writeFieldBegin("measure", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->measure);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dimension", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dimension);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chart_type", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->chart_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aggregate_type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->aggregate_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statistical_method", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->statistical_method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aggregate_data", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->aggregate_data.size()));
    std::map<std::string, double> ::const_iterator _iter7;
    for (_iter7 = this->aggregate_data.begin(); _iter7 != this->aggregate_data.end(); ++_iter7)
    {
      xfer += oprot->writeString(_iter7->first);
      xfer += oprot->writeDouble(_iter7->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("score", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->score);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Suggestion &a, Suggestion &b) {
  using ::std::swap;
  swap(a.measure, b.measure);
  swap(a.dimension, b.dimension);
  swap(a.chart_type, b.chart_type);
  swap(a.aggregate_type, b.aggregate_type);
  swap(a.statistical_method, b.statistical_method);
  swap(a.aggregate_data, b.aggregate_data);
  swap(a.score, b.score);
}

Suggestion::Suggestion(const Suggestion& other8) {
  measure = other8.measure;
  dimension = other8.dimension;
  chart_type = other8.chart_type;
  aggregate_type = other8.aggregate_type;
  statistical_method = other8.statistical_method;
  aggregate_data = other8.aggregate_data;
  score = other8.score;
}
Suggestion& Suggestion::operator=(const Suggestion& other9) {
  measure = other9.measure;
  dimension = other9.dimension;
  chart_type = other9.chart_type;
  aggregate_type = other9.aggregate_type;
  statistical_method = other9.statistical_method;
  aggregate_data = other9.aggregate_data;
  score = other9.score;
  return *this;
}
void Suggestion::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Suggestion(";
  out << "measure=" << to_string(measure);
  out << ", " << "dimension=" << to_string(dimension);
  out << ", " << "chart_type=" << to_string(chart_type);
  out << ", " << "aggregate_type=" << to_string(aggregate_type);
  out << ", " << "statistical_method=" << to_string(statistical_method);
  out << ", " << "aggregate_data=" << to_string(aggregate_data);
  out << ", " << "score=" << to_string(score);
  out << ")";
}


Attribute::~Attribute() throw() {
}


void Attribute::__set_name(const std::string& val) {
  this->name = val;
}

uint32_t Attribute::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Attribute::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Attribute");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Attribute &a, Attribute &b) {
  using ::std::swap;
  swap(a.name, b.name);
}

Attribute::Attribute(const Attribute& other10) {
  name = other10.name;
}
Attribute& Attribute::operator=(const Attribute& other11) {
  name = other11.name;
  return *this;
}
void Attribute::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Attribute(";
  out << "name=" << to_string(name);
  out << ")";
}

} // namespace
